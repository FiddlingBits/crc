/****************************************************************************************************
 * FILE:    crc.c
 * BRIEF:   Cyclic Redundancy Check (CRC) Source File
 ****************************************************************************************************/

/****************************************************************************************************
 * Definitions
 ****************************************************************************************************/

/*** CRC-8 ***/
/* CRC-8 */
#ifdef CRC_CRC8_LOOP_METHOD
  #define CRC_CRC8_POLYNOMIAL (0x07)
#endif

/* CRC-8/CDMA2000 */
#ifdef CRC_CRC8_CDMA2000_LOOP_METHOD
  #define CRC_CRC8_CDMA2000_POLYNOMIAL (0x9B)
#endif

/* CRC-8/DARC */
#ifdef CRC_CRC8_DARC_LOOP_METHOD
  #define CRC_CRC8_DARC_POLYNOMIAL (0x39)
#endif

/* CRC-8/DVB-S2 */
#ifdef CRC_CRC8_DVB_S2_LOOP_METHOD
  #define CRC_CRC8_DVB_S2_POLYNOMIAL (0xD5)
#endif

/* CRC-8/EBU */
#ifdef CRC_CRC8_EBU_LOOP_METHOD
  #define CRC_CRC8_EBU_POLYNOMIAL (0x1D)
#endif

/* CRC-8/I-CODE */
#ifdef CRC_CRC8_I_CODE_LOOP_METHOD
  #define CRC_CRC8_I_CODE_POLYNOMIAL (0x1D)
#endif

/* CRC-8/ITU*/
#ifdef CRC_CRC8_ITU_LOOP_METHOD
  #define CRC_CRC8_ITU_POLYNOMIAL (0x07)
#endif
#if defined(CRC_CRC8_ITU_LOOKUP_TABLE_METHOD) || defined(CRC_CRC8_ITU_LOOP_METHOD)
  #define CRC_CRC8_ITU_XOR_OUT (0x55)
#endif

/* CRC-8/MAXIM */
#ifdef CRC_CRC8_MAXIM_LOOP_METHOD
  #define CRC_CRC8_MAXIM_POLYNOMIAL (0x31)
#endif

/* CRC-8/ROHC */
#ifdef CRC_CRC8_ROHC_LOOP_METHOD
  #define CRC_CRC8_ROHC_POLYNOMIAL (0x07)
#endif

/* CRC-8/WCDMA */
#ifdef CRC_CRC8_WCDMA_LOOP_METHOD
  #define CRC_CRC8_WCDMA_POLYNOMIAL (0x9B)
#endif

/*** CRC-16 ***/
/* CRC-16/ARC */
#ifdef CRC_CRC16_ARC_LOOP_METHOD
  #define CRC_CRC16_ARC_POLYNOMIAL (0x8005)
#endif

/* CRC-16/CCITT-FALSE */
#ifdef CRC_CRC16_CCITT_FALSE_LOOP_METHOD
  #define CRC_CRC16_CCITT_FALSE_POLYNOMIAL (0x1021)
#endif

/*** Reflect ***/
/* U8 */
#if defined(CRC_CRC8_DARC_LOOP_METHOD)  || \
    defined(CRC_CRC8_EBU_LOOP_METHOD)   || \
    defined(CRC_CRC8_MAXIM_LOOP_METHOD) || \
    defined(CRC_CRC8_ROHC_LOOP_METHOD)  || \
    defined(CRC_CRC8_WCDMA_LOOP_METHOD) || \
    defined(CRC_CRC16_ARC_LOOP_METHOD)
  #ifndef CRC_REFLECT_U8
    #define CRC_REFLECT_U8
  #endif
#endif

/* U16 */
#if defined(CRC_CRC16_ARC_LOOP_METHOD)
  #ifndef CRC_REFLECT_U16
    #define CRC_REFLECT_U16
  #endif
#endif

/****************************************************************************************************
 * Includes
 ****************************************************************************************************/

#include "crc.h"
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>

/****************************************************************************************************
 * Constants and Variables
 ****************************************************************************************************/

/*** CRC-8 ***/
/* CRC-8 */
#ifdef CRC_CRC8_LOOKUP_TABLE_METHOD
  static const uint8_t crc_crc8LookupTable[256] =
  {
      0x00, 0x07, 0x0E, 0x09, 0x1C, 0x1B, 0x12, 0x15, 0x38, 0x3F, 0x36, 0x31, 0x24, 0x23, 0x2A, 0x2D,
      0x70, 0x77, 0x7E, 0x79, 0x6C, 0x6B, 0x62, 0x65, 0x48, 0x4F, 0x46, 0x41, 0x54, 0x53, 0x5A, 0x5D,
      0xE0, 0xE7, 0xEE, 0xE9, 0xFC, 0xFB, 0xF2, 0xF5, 0xD8, 0xDF, 0xD6, 0xD1, 0xC4, 0xC3, 0xCA, 0xCD,
      0x90, 0x97, 0x9E, 0x99, 0x8C, 0x8B, 0x82, 0x85, 0xA8, 0xAF, 0xA6, 0xA1, 0xB4, 0xB3, 0xBA, 0xBD,
      0xC7, 0xC0, 0xC9, 0xCE, 0xDB, 0xDC, 0xD5, 0xD2, 0xFF, 0xF8, 0xF1, 0xF6, 0xE3, 0xE4, 0xED, 0xEA,
      0xB7, 0xB0, 0xB9, 0xBE, 0xAB, 0xAC, 0xA5, 0xA2, 0x8F, 0x88, 0x81, 0x86, 0x93, 0x94, 0x9D, 0x9A,
      0x27, 0x20, 0x29, 0x2E, 0x3B, 0x3C, 0x35, 0x32, 0x1F, 0x18, 0x11, 0x16, 0x03, 0x04, 0x0D, 0x0A,
      0x57, 0x50, 0x59, 0x5E, 0x4B, 0x4C, 0x45, 0x42, 0x6F, 0x68, 0x61, 0x66, 0x73, 0x74, 0x7D, 0x7A,
      0x89, 0x8E, 0x87, 0x80, 0x95, 0x92, 0x9B, 0x9C, 0xB1, 0xB6, 0xBF, 0xB8, 0xAD, 0xAA, 0xA3, 0xA4,
      0xF9, 0xFE, 0xF7, 0xF0, 0xE5, 0xE2, 0xEB, 0xEC, 0xC1, 0xC6, 0xCF, 0xC8, 0xDD, 0xDA, 0xD3, 0xD4,
      0x69, 0x6E, 0x67, 0x60, 0x75, 0x72, 0x7B, 0x7C, 0x51, 0x56, 0x5F, 0x58, 0x4D, 0x4A, 0x43, 0x44,
      0x19, 0x1E, 0x17, 0x10, 0x05, 0x02, 0x0B, 0x0C, 0x21, 0x26, 0x2F, 0x28, 0x3D, 0x3A, 0x33, 0x34,
      0x4E, 0x49, 0x40, 0x47, 0x52, 0x55, 0x5C, 0x5B, 0x76, 0x71, 0x78, 0x7F, 0x6A, 0x6D, 0x64, 0x63,
      0x3E, 0x39, 0x30, 0x37, 0x22, 0x25, 0x2C, 0x2B, 0x06, 0x01, 0x08, 0x0F, 0x1A, 0x1D, 0x14, 0x13,
      0xAE, 0xA9, 0xA0, 0xA7, 0xB2, 0xB5, 0xBC, 0xBB, 0x96, 0x91, 0x98, 0x9F, 0x8A, 0x8D, 0x84, 0x83,
      0xDE, 0xD9, 0xD0, 0xD7, 0xC2, 0xC5, 0xCC, 0xCB, 0xE6, 0xE1, 0xE8, 0xEF, 0xFA, 0xFD, 0xF4, 0xF3
  };
#endif

/* CRC-8/CDMA2000 */
#ifdef CRC_CRC8_CDMA2000_LOOKUP_TABLE_METHOD
  static const uint8_t crc_crc8Cdma2000LookupTable[256] =
  {
      0x7B, 0xE0, 0xD6, 0x4D, 0xBA, 0x21, 0x17, 0x8C, 0x62, 0xF9, 0xCF, 0x54, 0xA3, 0x38, 0x0E, 0x95,
      0x49, 0xD2, 0xE4, 0x7F, 0x88, 0x13, 0x25, 0xBE, 0x50, 0xCB, 0xFD, 0x66, 0x91, 0x0A, 0x3C, 0xA7,
      0x1F, 0x84, 0xB2, 0x29, 0xDE, 0x45, 0x73, 0xE8, 0x06, 0x9D, 0xAB, 0x30, 0xC7, 0x5C, 0x6A, 0xF1,
      0x2D, 0xB6, 0x80, 0x1B, 0xEC, 0x77, 0x41, 0xDA, 0x34, 0xAF, 0x99, 0x02, 0xF5, 0x6E, 0x58, 0xC3,
      0xB3, 0x28, 0x1E, 0x85, 0x72, 0xE9, 0xDF, 0x44, 0xAA, 0x31, 0x07, 0x9C, 0x6B, 0xF0, 0xC6, 0x5D,
      0x81, 0x1A, 0x2C, 0xB7, 0x40, 0xDB, 0xED, 0x76, 0x98, 0x03, 0x35, 0xAE, 0x59, 0xC2, 0xF4, 0x6F,
      0xD7, 0x4C, 0x7A, 0xE1, 0x16, 0x8D, 0xBB, 0x20, 0xCE, 0x55, 0x63, 0xF8, 0x0F, 0x94, 0xA2, 0x39,
      0xE5, 0x7E, 0x48, 0xD3, 0x24, 0xBF, 0x89, 0x12, 0xFC, 0x67, 0x51, 0xCA, 0x3D, 0xA6, 0x90, 0x0B,
      0x70, 0xEB, 0xDD, 0x46, 0xB1, 0x2A, 0x1C, 0x87, 0x69, 0xF2, 0xC4, 0x5F, 0xA8, 0x33, 0x05, 0x9E,
      0x42, 0xD9, 0xEF, 0x74, 0x83, 0x18, 0x2E, 0xB5, 0x5B, 0xC0, 0xF6, 0x6D, 0x9A, 0x01, 0x37, 0xAC,
      0x14, 0x8F, 0xB9, 0x22, 0xD5, 0x4E, 0x78, 0xE3, 0x0D, 0x96, 0xA0, 0x3B, 0xCC, 0x57, 0x61, 0xFA,
      0x26, 0xBD, 0x8B, 0x10, 0xE7, 0x7C, 0x4A, 0xD1, 0x3F, 0xA4, 0x92, 0x09, 0xFE, 0x65, 0x53, 0xC8,
      0xB8, 0x23, 0x15, 0x8E, 0x79, 0xE2, 0xD4, 0x4F, 0xA1, 0x3A, 0x0C, 0x97, 0x60, 0xFB, 0xCD, 0x56,
      0x8A, 0x11, 0x27, 0xBC, 0x4B, 0xD0, 0xE6, 0x7D, 0x93, 0x08, 0x3E, 0xA5, 0x52, 0xC9, 0xFF, 0x64,
      0xDC, 0x47, 0x71, 0xEA, 0x1D, 0x86, 0xB0, 0x2B, 0xC5, 0x5E, 0x68, 0xF3, 0x04, 0x9F, 0xA9, 0x32,
      0xEE, 0x75, 0x43, 0xD8, 0x2F, 0xB4, 0x82, 0x19, 0xF7, 0x6C, 0x5A, 0xC1, 0x36, 0xAD, 0x9B, 0x00
  };
#endif

/* CRC-8/DARC */
#ifdef CRC_CRC8_DARC_LOOKUP_TABLE_METHOD
  static const uint8_t crc_crc8DarcLookupTable[256] =
  {
      0x00, 0x72, 0xE4, 0x96, 0xF1, 0x83, 0x15, 0x67, 0xDB, 0xA9, 0x3F, 0x4D, 0x2A, 0x58, 0xCE, 0xBC,
      0x8F, 0xFD, 0x6B, 0x19, 0x7E, 0x0C, 0x9A, 0xE8, 0x54, 0x26, 0xB0, 0xC2, 0xA5, 0xD7, 0x41, 0x33,
      0x27, 0x55, 0xC3, 0xB1, 0xD6, 0xA4, 0x32, 0x40, 0xFC, 0x8E, 0x18, 0x6A, 0x0D, 0x7F, 0xE9, 0x9B,
      0xA8, 0xDA, 0x4C, 0x3E, 0x59, 0x2B, 0xBD, 0xCF, 0x73, 0x01, 0x97, 0xE5, 0x82, 0xF0, 0x66, 0x14,
      0x4E, 0x3C, 0xAA, 0xD8, 0xBF, 0xCD, 0x5B, 0x29, 0x95, 0xE7, 0x71, 0x03, 0x64, 0x16, 0x80, 0xF2,
      0xC1, 0xB3, 0x25, 0x57, 0x30, 0x42, 0xD4, 0xA6, 0x1A, 0x68, 0xFE, 0x8C, 0xEB, 0x99, 0x0F, 0x7D,
      0x69, 0x1B, 0x8D, 0xFF, 0x98, 0xEA, 0x7C, 0x0E, 0xB2, 0xC0, 0x56, 0x24, 0x43, 0x31, 0xA7, 0xD5,
      0xE6, 0x94, 0x02, 0x70, 0x17, 0x65, 0xF3, 0x81, 0x3D, 0x4F, 0xD9, 0xAB, 0xCC, 0xBE, 0x28, 0x5A,
      0x9C, 0xEE, 0x78, 0x0A, 0x6D, 0x1F, 0x89, 0xFB, 0x47, 0x35, 0xA3, 0xD1, 0xB6, 0xC4, 0x52, 0x20,
      0x13, 0x61, 0xF7, 0x85, 0xE2, 0x90, 0x06, 0x74, 0xC8, 0xBA, 0x2C, 0x5E, 0x39, 0x4B, 0xDD, 0xAF,
      0xBB, 0xC9, 0x5F, 0x2D, 0x4A, 0x38, 0xAE, 0xDC, 0x60, 0x12, 0x84, 0xF6, 0x91, 0xE3, 0x75, 0x07,
      0x34, 0x46, 0xD0, 0xA2, 0xC5, 0xB7, 0x21, 0x53, 0xEF, 0x9D, 0x0B, 0x79, 0x1E, 0x6C, 0xFA, 0x88,
      0xD2, 0xA0, 0x36, 0x44, 0x23, 0x51, 0xC7, 0xB5, 0x09, 0x7B, 0xED, 0x9F, 0xF8, 0x8A, 0x1C, 0x6E,
      0x5D, 0x2F, 0xB9, 0xCB, 0xAC, 0xDE, 0x48, 0x3A, 0x86, 0xF4, 0x62, 0x10, 0x77, 0x05, 0x93, 0xE1,
      0xF5, 0x87, 0x11, 0x63, 0x04, 0x76, 0xE0, 0x92, 0x2E, 0x5C, 0xCA, 0xB8, 0xDF, 0xAD, 0x3B, 0x49,
      0x7A, 0x08, 0x9E, 0xEC, 0x8B, 0xF9, 0x6F, 0x1D, 0xA1, 0xD3, 0x45, 0x37, 0x50, 0x22, 0xB4, 0xC6
  };
#endif

/* CRC-8/DVB-S2 */
#ifdef CRC_CRC8_DVB_S2_LOOKUP_TABLE_METHOD
  static const uint8_t crc_crc8DvbS2LookupTable[256] =
  {
      0x00, 0xD5, 0x7F, 0xAA, 0xFE, 0x2B, 0x81, 0x54, 0x29, 0xFC, 0x56, 0x83, 0xD7, 0x02, 0xA8, 0x7D,
      0x52, 0x87, 0x2D, 0xF8, 0xAC, 0x79, 0xD3, 0x06, 0x7B, 0xAE, 0x04, 0xD1, 0x85, 0x50, 0xFA, 0x2F,
      0xA4, 0x71, 0xDB, 0x0E, 0x5A, 0x8F, 0x25, 0xF0, 0x8D, 0x58, 0xF2, 0x27, 0x73, 0xA6, 0x0C, 0xD9,
      0xF6, 0x23, 0x89, 0x5C, 0x08, 0xDD, 0x77, 0xA2, 0xDF, 0x0A, 0xA0, 0x75, 0x21, 0xF4, 0x5E, 0x8B,
      0x9D, 0x48, 0xE2, 0x37, 0x63, 0xB6, 0x1C, 0xC9, 0xB4, 0x61, 0xCB, 0x1E, 0x4A, 0x9F, 0x35, 0xE0,
      0xCF, 0x1A, 0xB0, 0x65, 0x31, 0xE4, 0x4E, 0x9B, 0xE6, 0x33, 0x99, 0x4C, 0x18, 0xCD, 0x67, 0xB2,
      0x39, 0xEC, 0x46, 0x93, 0xC7, 0x12, 0xB8, 0x6D, 0x10, 0xC5, 0x6F, 0xBA, 0xEE, 0x3B, 0x91, 0x44,
      0x6B, 0xBE, 0x14, 0xC1, 0x95, 0x40, 0xEA, 0x3F, 0x42, 0x97, 0x3D, 0xE8, 0xBC, 0x69, 0xC3, 0x16,
      0xEF, 0x3A, 0x90, 0x45, 0x11, 0xC4, 0x6E, 0xBB, 0xC6, 0x13, 0xB9, 0x6C, 0x38, 0xED, 0x47, 0x92,
      0xBD, 0x68, 0xC2, 0x17, 0x43, 0x96, 0x3C, 0xE9, 0x94, 0x41, 0xEB, 0x3E, 0x6A, 0xBF, 0x15, 0xC0,
      0x4B, 0x9E, 0x34, 0xE1, 0xB5, 0x60, 0xCA, 0x1F, 0x62, 0xB7, 0x1D, 0xC8, 0x9C, 0x49, 0xE3, 0x36,
      0x19, 0xCC, 0x66, 0xB3, 0xE7, 0x32, 0x98, 0x4D, 0x30, 0xE5, 0x4F, 0x9A, 0xCE, 0x1B, 0xB1, 0x64,
      0x72, 0xA7, 0x0D, 0xD8, 0x8C, 0x59, 0xF3, 0x26, 0x5B, 0x8E, 0x24, 0xF1, 0xA5, 0x70, 0xDA, 0x0F,
      0x20, 0xF5, 0x5F, 0x8A, 0xDE, 0x0B, 0xA1, 0x74, 0x09, 0xDC, 0x76, 0xA3, 0xF7, 0x22, 0x88, 0x5D,
      0xD6, 0x03, 0xA9, 0x7C, 0x28, 0xFD, 0x57, 0x82, 0xFF, 0x2A, 0x80, 0x55, 0x01, 0xD4, 0x7E, 0xAB,
      0x84, 0x51, 0xFB, 0x2E, 0x7A, 0xAF, 0x05, 0xD0, 0xAD, 0x78, 0xD2, 0x07, 0x53, 0x86, 0x2C, 0xF9
  };
#endif

/* CRC-8/EBU */
#ifdef CRC_CRC8_EBU_LOOKUP_TABLE_METHOD
  static const uint8_t crc_crc8EbuLookupTable[256] =
  {
      0x23, 0x47, 0xEB, 0x8F, 0xC2, 0xA6, 0x0A, 0x6E, 0x90, 0xF4, 0x58, 0x3C, 0x71, 0x15, 0xB9, 0xDD,
      0x34, 0x50, 0xFC, 0x98, 0xD5, 0xB1, 0x1D, 0x79, 0x87, 0xE3, 0x4F, 0x2B, 0x66, 0x02, 0xAE, 0xCA,
      0x0D, 0x69, 0xC5, 0xA1, 0xEC, 0x88, 0x24, 0x40, 0xBE, 0xDA, 0x76, 0x12, 0x5F, 0x3B, 0x97, 0xF3,
      0x1A, 0x7E, 0xD2, 0xB6, 0xFB, 0x9F, 0x33, 0x57, 0xA9, 0xCD, 0x61, 0x05, 0x48, 0x2C, 0x80, 0xE4,
      0x7F, 0x1B, 0xB7, 0xD3, 0x9E, 0xFA, 0x56, 0x32, 0xCC, 0xA8, 0x04, 0x60, 0x2D, 0x49, 0xE5, 0x81,
      0x68, 0x0C, 0xA0, 0xC4, 0x89, 0xED, 0x41, 0x25, 0xDB, 0xBF, 0x13, 0x77, 0x3A, 0x5E, 0xF2, 0x96,
      0x51, 0x35, 0x99, 0xFD, 0xB0, 0xD4, 0x78, 0x1C, 0xE2, 0x86, 0x2A, 0x4E, 0x03, 0x67, 0xCB, 0xAF,
      0x46, 0x22, 0x8E, 0xEA, 0xA7, 0xC3, 0x6F, 0x0B, 0xF5, 0x91, 0x3D, 0x59, 0x14, 0x70, 0xDC, 0xB8,
      0x9B, 0xFF, 0x53, 0x37, 0x7A, 0x1E, 0xB2, 0xD6, 0x28, 0x4C, 0xE0, 0x84, 0xC9, 0xAD, 0x01, 0x65,
      0x8C, 0xE8, 0x44, 0x20, 0x6D, 0x09, 0xA5, 0xC1, 0x3F, 0x5B, 0xF7, 0x93, 0xDE, 0xBA, 0x16, 0x72,
      0xB5, 0xD1, 0x7D, 0x19, 0x54, 0x30, 0x9C, 0xF8, 0x06, 0x62, 0xCE, 0xAA, 0xE7, 0x83, 0x2F, 0x4B,
      0xA2, 0xC6, 0x6A, 0x0E, 0x43, 0x27, 0x8B, 0xEF, 0x11, 0x75, 0xD9, 0xBD, 0xF0, 0x94, 0x38, 0x5C,
      0xC7, 0xA3, 0x0F, 0x6B, 0x26, 0x42, 0xEE, 0x8A, 0x74, 0x10, 0xBC, 0xD8, 0x95, 0xF1, 0x5D, 0x39,
      0xD0, 0xB4, 0x18, 0x7C, 0x31, 0x55, 0xF9, 0x9D, 0x63, 0x07, 0xAB, 0xCF, 0x82, 0xE6, 0x4A, 0x2E,
      0xE9, 0x8D, 0x21, 0x45, 0x08, 0x6C, 0xC0, 0xA4, 0x5A, 0x3E, 0x92, 0xF6, 0xBB, 0xDF, 0x73, 0x17,
      0xFE, 0x9A, 0x36, 0x52, 0x1F, 0x7B, 0xD7, 0xB3, 0x4D, 0x29, 0x85, 0xE1, 0xAC, 0xC8, 0x64, 0x00
  };
#endif

/* CRC-8/I-CODE */
#ifdef CRC_CRC8_I_CODE_LOOKUP_TABLE_METHOD
  static const uint8_t crc_crc8ICodeLookupTable[256] =
  {
      0xFE, 0xE3, 0xC4, 0xD9, 0x8A, 0x97, 0xB0, 0xAD, 0x16, 0x0B, 0x2C, 0x31, 0x62, 0x7F, 0x58, 0x45,
      0x33, 0x2E, 0x09, 0x14, 0x47, 0x5A, 0x7D, 0x60, 0xDB, 0xC6, 0xE1, 0xFC, 0xAF, 0xB2, 0x95, 0x88,
      0x79, 0x64, 0x43, 0x5E, 0x0D, 0x10, 0x37, 0x2A, 0x91, 0x8C, 0xAB, 0xB6, 0xE5, 0xF8, 0xDF, 0xC2,
      0xB4, 0xA9, 0x8E, 0x93, 0xC0, 0xDD, 0xFA, 0xE7, 0x5C, 0x41, 0x66, 0x7B, 0x28, 0x35, 0x12, 0x0F,
      0xED, 0xF0, 0xD7, 0xCA, 0x99, 0x84, 0xA3, 0xBE, 0x05, 0x18, 0x3F, 0x22, 0x71, 0x6C, 0x4B, 0x56,
      0x20, 0x3D, 0x1A, 0x07, 0x54, 0x49, 0x6E, 0x73, 0xC8, 0xD5, 0xF2, 0xEF, 0xBC, 0xA1, 0x86, 0x9B,
      0x6A, 0x77, 0x50, 0x4D, 0x1E, 0x03, 0x24, 0x39, 0x82, 0x9F, 0xB8, 0xA5, 0xF6, 0xEB, 0xCC, 0xD1,
      0xA7, 0xBA, 0x9D, 0x80, 0xD3, 0xCE, 0xE9, 0xF4, 0x4F, 0x52, 0x75, 0x68, 0x3B, 0x26, 0x01, 0x1C,
      0xD8, 0xC5, 0xE2, 0xFF, 0xAC, 0xB1, 0x96, 0x8B, 0x30, 0x2D, 0x0A, 0x17, 0x44, 0x59, 0x7E, 0x63,
      0x15, 0x08, 0x2F, 0x32, 0x61, 0x7C, 0x5B, 0x46, 0xFD, 0xE0, 0xC7, 0xDA, 0x89, 0x94, 0xB3, 0xAE,
      0x5F, 0x42, 0x65, 0x78, 0x2B, 0x36, 0x11, 0x0C, 0xB7, 0xAA, 0x8D, 0x90, 0xC3, 0xDE, 0xF9, 0xE4,
      0x92, 0x8F, 0xA8, 0xB5, 0xE6, 0xFB, 0xDC, 0xC1, 0x7A, 0x67, 0x40, 0x5D, 0x0E, 0x13, 0x34, 0x29,
      0xCB, 0xD6, 0xF1, 0xEC, 0xBF, 0xA2, 0x85, 0x98, 0x23, 0x3E, 0x19, 0x04, 0x57, 0x4A, 0x6D, 0x70,
      0x06, 0x1B, 0x3C, 0x21, 0x72, 0x6F, 0x48, 0x55, 0xEE, 0xF3, 0xD4, 0xC9, 0x9A, 0x87, 0xA0, 0xBD,
      0x4C, 0x51, 0x76, 0x6B, 0x38, 0x25, 0x02, 0x1F, 0xA4, 0xB9, 0x9E, 0x83, 0xD0, 0xCD, 0xEA, 0xF7,
      0x81, 0x9C, 0xBB, 0xA6, 0xF5, 0xE8, 0xCF, 0xD2, 0x69, 0x74, 0x53, 0x4E, 0x1D, 0x00, 0x27, 0x3A
  };
#endif

/* CRC-8/ITU */
#ifdef CRC_CRC8_ITU_LOOKUP_TABLE_METHOD
  static const uint8_t crc_crc8ItuLookupTable[256] =
  {
      0x00, 0x07, 0x0E, 0x09, 0x1C, 0x1B, 0x12, 0x15, 0x38, 0x3F, 0x36, 0x31, 0x24, 0x23, 0x2A, 0x2D,
      0x70, 0x77, 0x7E, 0x79, 0x6C, 0x6B, 0x62, 0x65, 0x48, 0x4F, 0x46, 0x41, 0x54, 0x53, 0x5A, 0x5D,
      0xE0, 0xE7, 0xEE, 0xE9, 0xFC, 0xFB, 0xF2, 0xF5, 0xD8, 0xDF, 0xD6, 0xD1, 0xC4, 0xC3, 0xCA, 0xCD,
      0x90, 0x97, 0x9E, 0x99, 0x8C, 0x8B, 0x82, 0x85, 0xA8, 0xAF, 0xA6, 0xA1, 0xB4, 0xB3, 0xBA, 0xBD,
      0xC7, 0xC0, 0xC9, 0xCE, 0xDB, 0xDC, 0xD5, 0xD2, 0xFF, 0xF8, 0xF1, 0xF6, 0xE3, 0xE4, 0xED, 0xEA,
      0xB7, 0xB0, 0xB9, 0xBE, 0xAB, 0xAC, 0xA5, 0xA2, 0x8F, 0x88, 0x81, 0x86, 0x93, 0x94, 0x9D, 0x9A,
      0x27, 0x20, 0x29, 0x2E, 0x3B, 0x3C, 0x35, 0x32, 0x1F, 0x18, 0x11, 0x16, 0x03, 0x04, 0x0D, 0x0A,
      0x57, 0x50, 0x59, 0x5E, 0x4B, 0x4C, 0x45, 0x42, 0x6F, 0x68, 0x61, 0x66, 0x73, 0x74, 0x7D, 0x7A,
      0x89, 0x8E, 0x87, 0x80, 0x95, 0x92, 0x9B, 0x9C, 0xB1, 0xB6, 0xBF, 0xB8, 0xAD, 0xAA, 0xA3, 0xA4,
      0xF9, 0xFE, 0xF7, 0xF0, 0xE5, 0xE2, 0xEB, 0xEC, 0xC1, 0xC6, 0xCF, 0xC8, 0xDD, 0xDA, 0xD3, 0xD4,
      0x69, 0x6E, 0x67, 0x60, 0x75, 0x72, 0x7B, 0x7C, 0x51, 0x56, 0x5F, 0x58, 0x4D, 0x4A, 0x43, 0x44,
      0x19, 0x1E, 0x17, 0x10, 0x05, 0x02, 0x0B, 0x0C, 0x21, 0x26, 0x2F, 0x28, 0x3D, 0x3A, 0x33, 0x34,
      0x4E, 0x49, 0x40, 0x47, 0x52, 0x55, 0x5C, 0x5B, 0x76, 0x71, 0x78, 0x7F, 0x6A, 0x6D, 0x64, 0x63,
      0x3E, 0x39, 0x30, 0x37, 0x22, 0x25, 0x2C, 0x2B, 0x06, 0x01, 0x08, 0x0F, 0x1A, 0x1D, 0x14, 0x13,
      0xAE, 0xA9, 0xA0, 0xA7, 0xB2, 0xB5, 0xBC, 0xBB, 0x96, 0x91, 0x98, 0x9F, 0x8A, 0x8D, 0x84, 0x83,
      0xDE, 0xD9, 0xD0, 0xD7, 0xC2, 0xC5, 0xCC, 0xCB, 0xE6, 0xE1, 0xE8, 0xEF, 0xFA, 0xFD, 0xF4, 0xF3
  };
#endif

/* CRC-8/MAXIM */
#ifdef CRC_CRC8_MAXIM_LOOKUP_TABLE_METHOD
  static const uint8_t crc_crc8MaximLookupTable[256] =
  {
      0x00, 0x5E, 0xBC, 0xE2, 0x61, 0x3F, 0xDD, 0x83, 0xC2, 0x9C, 0x7E, 0x20, 0xA3, 0xFD, 0x1F, 0x41,
      0x9D, 0xC3, 0x21, 0x7F, 0xFC, 0xA2, 0x40, 0x1E, 0x5F, 0x01, 0xE3, 0xBD, 0x3E, 0x60, 0x82, 0xDC,
      0x23, 0x7D, 0x9F, 0xC1, 0x42, 0x1C, 0xFE, 0xA0, 0xE1, 0xBF, 0x5D, 0x03, 0x80, 0xDE, 0x3C, 0x62,
      0xBE, 0xE0, 0x02, 0x5C, 0xDF, 0x81, 0x63, 0x3D, 0x7C, 0x22, 0xC0, 0x9E, 0x1D, 0x43, 0xA1, 0xFF,
      0x46, 0x18, 0xFA, 0xA4, 0x27, 0x79, 0x9B, 0xC5, 0x84, 0xDA, 0x38, 0x66, 0xE5, 0xBB, 0x59, 0x07,
      0xDB, 0x85, 0x67, 0x39, 0xBA, 0xE4, 0x06, 0x58, 0x19, 0x47, 0xA5, 0xFB, 0x78, 0x26, 0xC4, 0x9A,
      0x65, 0x3B, 0xD9, 0x87, 0x04, 0x5A, 0xB8, 0xE6, 0xA7, 0xF9, 0x1B, 0x45, 0xC6, 0x98, 0x7A, 0x24,
      0xF8, 0xA6, 0x44, 0x1A, 0x99, 0xC7, 0x25, 0x7B, 0x3A, 0x64, 0x86, 0xD8, 0x5B, 0x05, 0xE7, 0xB9,
      0x8C, 0xD2, 0x30, 0x6E, 0xED, 0xB3, 0x51, 0x0F, 0x4E, 0x10, 0xF2, 0xAC, 0x2F, 0x71, 0x93, 0xCD,
      0x11, 0x4F, 0xAD, 0xF3, 0x70, 0x2E, 0xCC, 0x92, 0xD3, 0x8D, 0x6F, 0x31, 0xB2, 0xEC, 0x0E, 0x50,
      0xAF, 0xF1, 0x13, 0x4D, 0xCE, 0x90, 0x72, 0x2C, 0x6D, 0x33, 0xD1, 0x8F, 0x0C, 0x52, 0xB0, 0xEE,
      0x32, 0x6C, 0x8E, 0xD0, 0x53, 0x0D, 0xEF, 0xB1, 0xF0, 0xAE, 0x4C, 0x12, 0x91, 0xCF, 0x2D, 0x73,
      0xCA, 0x94, 0x76, 0x28, 0xAB, 0xF5, 0x17, 0x49, 0x08, 0x56, 0xB4, 0xEA, 0x69, 0x37, 0xD5, 0x8B,
      0x57, 0x09, 0xEB, 0xB5, 0x36, 0x68, 0x8A, 0xD4, 0x95, 0xCB, 0x29, 0x77, 0xF4, 0xAA, 0x48, 0x16,
      0xE9, 0xB7, 0x55, 0x0B, 0x88, 0xD6, 0x34, 0x6A, 0x2B, 0x75, 0x97, 0xC9, 0x4A, 0x14, 0xF6, 0xA8,
      0x74, 0x2A, 0xC8, 0x96, 0x15, 0x4B, 0xA9, 0xF7, 0xB6, 0xE8, 0x0A, 0x54, 0xD7, 0x89, 0x6B, 0x35
  };
#endif

/* CRC-8/ROHC */
#ifdef CRC_CRC8_ROHC_LOOKUP_TABLE_METHOD
  static const uint8_t crc_crc8RohcLookupTable[256] =
  {
      0xCF, 0x5E, 0x2C, 0xBD, 0xC8, 0x59, 0x2B, 0xBA, 0xC1, 0x50, 0x22, 0xB3, 0xC6, 0x57, 0x25, 0xB4,
      0xD3, 0x42, 0x30, 0xA1, 0xD4, 0x45, 0x37, 0xA6, 0xDD, 0x4C, 0x3E, 0xAF, 0xDA, 0x4B, 0x39, 0xA8,
      0xF7, 0x66, 0x14, 0x85, 0xF0, 0x61, 0x13, 0x82, 0xF9, 0x68, 0x1A, 0x8B, 0xFE, 0x6F, 0x1D, 0x8C,
      0xEB, 0x7A, 0x08, 0x99, 0xEC, 0x7D, 0x0F, 0x9E, 0xE5, 0x74, 0x06, 0x97, 0xE2, 0x73, 0x01, 0x90,
      0xBF, 0x2E, 0x5C, 0xCD, 0xB8, 0x29, 0x5B, 0xCA, 0xB1, 0x20, 0x52, 0xC3, 0xB6, 0x27, 0x55, 0xC4,
      0xA3, 0x32, 0x40, 0xD1, 0xA4, 0x35, 0x47, 0xD6, 0xAD, 0x3C, 0x4E, 0xDF, 0xAA, 0x3B, 0x49, 0xD8,
      0x87, 0x16, 0x64, 0xF5, 0x80, 0x11, 0x63, 0xF2, 0x89, 0x18, 0x6A, 0xFB, 0x8E, 0x1F, 0x6D, 0xFC,
      0x9B, 0x0A, 0x78, 0xE9, 0x9C, 0x0D, 0x7F, 0xEE, 0x95, 0x04, 0x76, 0xE7, 0x92, 0x03, 0x71, 0xE0,
      0x2F, 0xBE, 0xCC, 0x5D, 0x28, 0xB9, 0xCB, 0x5A, 0x21, 0xB0, 0xC2, 0x53, 0x26, 0xB7, 0xC5, 0x54,
      0x33, 0xA2, 0xD0, 0x41, 0x34, 0xA5, 0xD7, 0x46, 0x3D, 0xAC, 0xDE, 0x4F, 0x3A, 0xAB, 0xD9, 0x48,
      0x17, 0x86, 0xF4, 0x65, 0x10, 0x81, 0xF3, 0x62, 0x19, 0x88, 0xFA, 0x6B, 0x1E, 0x8F, 0xFD, 0x6C,
      0x0B, 0x9A, 0xE8, 0x79, 0x0C, 0x9D, 0xEF, 0x7E, 0x05, 0x94, 0xE6, 0x77, 0x02, 0x93, 0xE1, 0x70,
      0x5F, 0xCE, 0xBC, 0x2D, 0x58, 0xC9, 0xBB, 0x2A, 0x51, 0xC0, 0xB2, 0x23, 0x56, 0xC7, 0xB5, 0x24,
      0x43, 0xD2, 0xA0, 0x31, 0x44, 0xD5, 0xA7, 0x36, 0x4D, 0xDC, 0xAE, 0x3F, 0x4A, 0xDB, 0xA9, 0x38,
      0x67, 0xF6, 0x84, 0x15, 0x60, 0xF1, 0x83, 0x12, 0x69, 0xF8, 0x8A, 0x1B, 0x6E, 0xFF, 0x8D, 0x1C,
      0x7B, 0xEA, 0x98, 0x09, 0x7C, 0xED, 0x9F, 0x0E, 0x75, 0xE4, 0x96, 0x07, 0x72, 0xE3, 0x91, 0x00
  };
#endif

/* CRC-8/WCDMA */
#ifdef CRC_CRC8_WCDMA_LOOKUP_TABLE_METHOD
  static const uint8_t crc_crc8WcdmaLookupTable[256] =
  {
      0x00, 0xD0, 0x13, 0xC3, 0x26, 0xF6, 0x35, 0xE5, 0x4C, 0x9C, 0x5F, 0x8F, 0x6A, 0xBA, 0x79, 0xA9,
      0x98, 0x48, 0x8B, 0x5B, 0xBE, 0x6E, 0xAD, 0x7D, 0xD4, 0x04, 0xC7, 0x17, 0xF2, 0x22, 0xE1, 0x31,
      0x83, 0x53, 0x90, 0x40, 0xA5, 0x75, 0xB6, 0x66, 0xCF, 0x1F, 0xDC, 0x0C, 0xE9, 0x39, 0xFA, 0x2A,
      0x1B, 0xCB, 0x08, 0xD8, 0x3D, 0xED, 0x2E, 0xFE, 0x57, 0x87, 0x44, 0x94, 0x71, 0xA1, 0x62, 0xB2,
      0xB5, 0x65, 0xA6, 0x76, 0x93, 0x43, 0x80, 0x50, 0xF9, 0x29, 0xEA, 0x3A, 0xDF, 0x0F, 0xCC, 0x1C,
      0x2D, 0xFD, 0x3E, 0xEE, 0x0B, 0xDB, 0x18, 0xC8, 0x61, 0xB1, 0x72, 0xA2, 0x47, 0x97, 0x54, 0x84,
      0x36, 0xE6, 0x25, 0xF5, 0x10, 0xC0, 0x03, 0xD3, 0x7A, 0xAA, 0x69, 0xB9, 0x5C, 0x8C, 0x4F, 0x9F,
      0xAE, 0x7E, 0xBD, 0x6D, 0x88, 0x58, 0x9B, 0x4B, 0xE2, 0x32, 0xF1, 0x21, 0xC4, 0x14, 0xD7, 0x07,
      0xD9, 0x09, 0xCA, 0x1A, 0xFF, 0x2F, 0xEC, 0x3C, 0x95, 0x45, 0x86, 0x56, 0xB3, 0x63, 0xA0, 0x70,
      0x41, 0x91, 0x52, 0x82, 0x67, 0xB7, 0x74, 0xA4, 0x0D, 0xDD, 0x1E, 0xCE, 0x2B, 0xFB, 0x38, 0xE8,
      0x5A, 0x8A, 0x49, 0x99, 0x7C, 0xAC, 0x6F, 0xBF, 0x16, 0xC6, 0x05, 0xD5, 0x30, 0xE0, 0x23, 0xF3,
      0xC2, 0x12, 0xD1, 0x01, 0xE4, 0x34, 0xF7, 0x27, 0x8E, 0x5E, 0x9D, 0x4D, 0xA8, 0x78, 0xBB, 0x6B,
      0x6C, 0xBC, 0x7F, 0xAF, 0x4A, 0x9A, 0x59, 0x89, 0x20, 0xF0, 0x33, 0xE3, 0x06, 0xD6, 0x15, 0xC5,
      0xF4, 0x24, 0xE7, 0x37, 0xD2, 0x02, 0xC1, 0x11, 0xB8, 0x68, 0xAB, 0x7B, 0x9E, 0x4E, 0x8D, 0x5D,
      0xEF, 0x3F, 0xFC, 0x2C, 0xC9, 0x19, 0xDA, 0x0A, 0xA3, 0x73, 0xB0, 0x60, 0x85, 0x55, 0x96, 0x46,
      0x77, 0xA7, 0x64, 0xB4, 0x51, 0x81, 0x42, 0x92, 0x3B, 0xEB, 0x28, 0xF8, 0x1D, 0xCD, 0x0E, 0xDE
  };
#endif

/*** CRC-16 ***/
/* CRC-16/ARC */
#ifdef CRC_CRC16_ARC_LOOKUP_TABLE_METHOD
  static const uint16_t crc_crc16ArcLookupTable[256] =
  {
      0x0000, 0xC0C1, 0xC181, 0x0140, 0xC301, 0x03C0, 0x0280, 0xC241, 0xC601, 0x06C0, 0x0780, 0xC741, 0x0500, 0xC5C1, 0xC481, 0x0440,
      0xCC01, 0x0CC0, 0x0D80, 0xCD41, 0x0F00, 0xCFC1, 0xCE81, 0x0E40, 0x0A00, 0xCAC1, 0xCB81, 0x0B40, 0xC901, 0x09C0, 0x0880, 0xC841,
      0xD801, 0x18C0, 0x1980, 0xD941, 0x1B00, 0xDBC1, 0xDA81, 0x1A40, 0x1E00, 0xDEC1, 0xDF81, 0x1F40, 0xDD01, 0x1DC0, 0x1C80, 0xDC41,
      0x1400, 0xD4C1, 0xD581, 0x1540, 0xD701, 0x17C0, 0x1680, 0xD641, 0xD201, 0x12C0, 0x1380, 0xD341, 0x1100, 0xD1C1, 0xD081, 0x1040,
      0xF001, 0x30C0, 0x3180, 0xF141, 0x3300, 0xF3C1, 0xF281, 0x3240, 0x3600, 0xF6C1, 0xF781, 0x3740, 0xF501, 0x35C0, 0x3480, 0xF441,
      0x3C00, 0xFCC1, 0xFD81, 0x3D40, 0xFF01, 0x3FC0, 0x3E80, 0xFE41, 0xFA01, 0x3AC0, 0x3B80, 0xFB41, 0x3900, 0xF9C1, 0xF881, 0x3840,
      0x2800, 0xE8C1, 0xE981, 0x2940, 0xEB01, 0x2BC0, 0x2A80, 0xEA41, 0xEE01, 0x2EC0, 0x2F80, 0xEF41, 0x2D00, 0xEDC1, 0xEC81, 0x2C40,
      0xE401, 0x24C0, 0x2580, 0xE541, 0x2700, 0xE7C1, 0xE681, 0x2640, 0x2200, 0xE2C1, 0xE381, 0x2340, 0xE101, 0x21C0, 0x2080, 0xE041,
      0xA001, 0x60C0, 0x6180, 0xA141, 0x6300, 0xA3C1, 0xA281, 0x6240, 0x6600, 0xA6C1, 0xA781, 0x6740, 0xA501, 0x65C0, 0x6480, 0xA441,
      0x6C00, 0xACC1, 0xAD81, 0x6D40, 0xAF01, 0x6FC0, 0x6E80, 0xAE41, 0xAA01, 0x6AC0, 0x6B80, 0xAB41, 0x6900, 0xA9C1, 0xA881, 0x6840,
      0x7800, 0xB8C1, 0xB981, 0x7940, 0xBB01, 0x7BC0, 0x7A80, 0xBA41, 0xBE01, 0x7EC0, 0x7F80, 0xBF41, 0x7D00, 0xBDC1, 0xBC81, 0x7C40,
      0xB401, 0x74C0, 0x7580, 0xB541, 0x7700, 0xB7C1, 0xB681, 0x7640, 0x7200, 0xB2C1, 0xB381, 0x7340, 0xB101, 0x71C0, 0x7080, 0xB041,
      0x5000, 0x90C1, 0x9181, 0x5140, 0x9301, 0x53C0, 0x5280, 0x9241, 0x9601, 0x56C0, 0x5780, 0x9741, 0x5500, 0x95C1, 0x9481, 0x5440,
      0x9C01, 0x5CC0, 0x5D80, 0x9D41, 0x5F00, 0x9FC1, 0x9E81, 0x5E40, 0x5A00, 0x9AC1, 0x9B81, 0x5B40, 0x9901, 0x59C0, 0x5880, 0x9841,
      0x8801, 0x48C0, 0x4980, 0x8941, 0x4B00, 0x8BC1, 0x8A81, 0x4A40, 0x4E00, 0x8EC1, 0x8F81, 0x4F40, 0x8D01, 0x4DC0, 0x4C80, 0x8C41,
      0x4400, 0x84C1, 0x8581, 0x4540, 0x8701, 0x47C0, 0x4680, 0x8641, 0x8201, 0x42C0, 0x4380, 0x8341, 0x4100, 0x81C1, 0x8081, 0x4040
  };
#endif

/* CRC-16/CCITT-FALSE */
#ifdef CRC_CRC16_CCITT_FALSE_LOOKUP_TABLE_METHOD
  static const uint16_t crc_crc16CcittFalseLookupTable[256] =
  {
      0xE1F0, 0xF1D1, 0xC1B2, 0xD193, 0xA174, 0xB155, 0x8136, 0x9117, 0x60F8, 0x70D9, 0x40BA, 0x509B, 0x207C, 0x305D, 0x003E, 0x101F,
      0xF3C1, 0xE3E0, 0xD383, 0xC3A2, 0xB345, 0xA364, 0x9307, 0x8326, 0x72C9, 0x62E8, 0x528B, 0x42AA, 0x324D, 0x226C, 0x120F, 0x022E,
      0xC592, 0xD5B3, 0xE5D0, 0xF5F1, 0x8516, 0x9537, 0xA554, 0xB575, 0x449A, 0x54BB, 0x64D8, 0x74F9, 0x041E, 0x143F, 0x245C, 0x347D,
      0xD7A3, 0xC782, 0xF7E1, 0xE7C0, 0x9727, 0x8706, 0xB765, 0xA744, 0x56AB, 0x468A, 0x76E9, 0x66C8, 0x162F, 0x060E, 0x366D, 0x264C,
      0xA934, 0xB915, 0x8976, 0x9957, 0xE9B0, 0xF991, 0xC9F2, 0xD9D3, 0x283C, 0x381D, 0x087E, 0x185F, 0x68B8, 0x7899, 0x48FA, 0x58DB,
      0xBB05, 0xAB24, 0x9B47, 0x8B66, 0xFB81, 0xEBA0, 0xDBC3, 0xCBE2, 0x3A0D, 0x2A2C, 0x1A4F, 0x0A6E, 0x7A89, 0x6AA8, 0x5ACB, 0x4AEA,
      0x8D56, 0x9D77, 0xAD14, 0xBD35, 0xCDD2, 0xDDF3, 0xED90, 0xFDB1, 0x0C5E, 0x1C7F, 0x2C1C, 0x3C3D, 0x4CDA, 0x5CFB, 0x6C98, 0x7CB9,
      0x9F67, 0x8F46, 0xBF25, 0xAF04, 0xDFE3, 0xCFC2, 0xFFA1, 0xEF80, 0x1E6F, 0x0E4E, 0x3E2D, 0x2E0C, 0x5EEB, 0x4ECA, 0x7EA9, 0x6E88,
      0x7078, 0x6059, 0x503A, 0x401B, 0x30FC, 0x20DD, 0x10BE, 0x009F, 0xF170, 0xE151, 0xD132, 0xC113, 0xB1F4, 0xA1D5, 0x91B6, 0x8197,
      0x6249, 0x7268, 0x420B, 0x522A, 0x22CD, 0x32EC, 0x028F, 0x12AE, 0xE341, 0xF360, 0xC303, 0xD322, 0xA3C5, 0xB3E4, 0x8387, 0x93A6,
      0x541A, 0x443B, 0x7458, 0x6479, 0x149E, 0x04BF, 0x34DC, 0x24FD, 0xD512, 0xC533, 0xF550, 0xE571, 0x9596, 0x85B7, 0xB5D4, 0xA5F5,
      0x462B, 0x560A, 0x6669, 0x7648, 0x06AF, 0x168E, 0x26ED, 0x36CC, 0xC723, 0xD702, 0xE761, 0xF740, 0x87A7, 0x9786, 0xA7E5, 0xB7C4,
      0x38BC, 0x289D, 0x18FE, 0x08DF, 0x7838, 0x6819, 0x587A, 0x485B, 0xB9B4, 0xA995, 0x99F6, 0x89D7, 0xF930, 0xE911, 0xD972, 0xC953,
      0x2A8D, 0x3AAC, 0x0ACF, 0x1AEE, 0x6A09, 0x7A28, 0x4A4B, 0x5A6A, 0xAB85, 0xBBA4, 0x8BC7, 0x9BE6, 0xEB01, 0xFB20, 0xCB43, 0xDB62,
      0x1CDE, 0x0CFF, 0x3C9C, 0x2CBD, 0x5C5A, 0x4C7B, 0x7C18, 0x6C39, 0x9DD6, 0x8DF7, 0xBD94, 0xADB5, 0xDD52, 0xCD73, 0xFD10, 0xED31,
      0x0EEF, 0x1ECE, 0x2EAD, 0x3E8C, 0x4E6B, 0x5E4A, 0x6E29, 0x7E08, 0x8FE7, 0x9FC6, 0xAFA5, 0xBF84, 0xCF63, 0xDF42, 0xEF21, 0xFF00
  };
#endif

/****************************************************************************************************
 * Function Prototypes
 ****************************************************************************************************/

/*** Reflect ***/
/* U8 */
#ifdef CRC_REFLECT_U8
  static uint8_t crc_reflectU8(const uint8_t Data);
#endif

/* U16 */
#ifdef CRC_REFLECT_U16
  static uint16_t crc_reflectU16(const uint16_t Data);
#endif

/****************************************************************************************************
 * Function Definitions (Public)
 ****************************************************************************************************/

#if defined(CRC_CRC8_LOOKUP_TABLE_METHOD) || defined(CRC_CRC8_LOOP_METHOD)
/****************************************************************************************************
 * FUNCT:   crc_crc8Calculate
 * BRIEF:   Calculate Full CRC-8
 * RETURN:  uint8_t: CRC-8
 * ARG:     Data: Data Buffer To Calculate CRC-8 For
 * ARG:     DataLength: Length Of Data Buffer
 ****************************************************************************************************/
uint8_t crc_crc8Calculate(const uint8_t * const Data, const uint16_t DataLength)
{
    uint8_t crc8 = CRC_CRC8_INITIAL_CRC8;
    uint32_t i;

    /*** Error Check ***/
    if((Data == NULL) || (DataLength == 0))
        return CRC_CRC8_INITIAL_CRC8;

    /*** Calculate Full CRC-8 ***/
    for(i = 0; i < DataLength; i++)
        crc8 = crc_crc8CalculatePartial(Data[i], crc8);

    return crc8;
}

/****************************************************************************************************
 * FUNCT:   crc_crc8CalculatePartial
 * BRIEF:   Calculate Partial CRC-8
 * RETURN:  uint8_t: Current/Final CRC-8
 * ARG:     Data: Data To Add To CRC-8 Calculation
 * ARG:     crc8: Current CRC-8
 * NOTE:    Set CRC-8 Value To CRC_CRC8_INITIAL_CRC8 If First Data Byte (Data[0]); Returned CRC-8
 *          Value Should Be Used On Subsequent Data Bytes (Data[1] ... Data[n])
 ****************************************************************************************************/
uint8_t crc_crc8CalculatePartial(const uint8_t Data, uint8_t crc8)
{
#if defined(CRC_CRC8_LOOKUP_TABLE_METHOD) && defined(CRC_CRC8_LOOP_METHOD)
  #error CRC_CRC8_LOOKUP_TABLE_METHOD And CRC_CRC8_LOOP_METHOD Cannot Both Be Defined
#elif defined(CRC_CRC8_LOOKUP_TABLE_METHOD) 
    /*** Calculate Partial CRC-8 ***/
    crc8 = crc_crc8LookupTable[Data ^ crc8];
    return crc8;
#elif defined(CRC_CRC8_LOOP_METHOD)
    uint8_t bit;
    
    /*** Calculate Partial CRC-8 ***/
    crc8 ^= Data;
    for(bit = 0; bit < 8; bit++)
    {
        if((crc8 & 0x80) == 0x80)
            crc8 = (uint8_t)((crc8 << 1) ^ CRC_CRC8_POLYNOMIAL);
        else
            crc8 <<= 1;
    }
    
    return crc8;
#endif
}
#endif

#if defined(CRC_CRC8_CDMA2000_LOOKUP_TABLE_METHOD) || defined(CRC_CRC8_CDMA2000_LOOP_METHOD)
/****************************************************************************************************
 * FUNCT:   crc_crc8Cdma2000Calculate
 * BRIEF:   Calculate Full CRC-8/CDMA2000
 * RETURN:  uint8_t: CRC-8/CDMA2000
 * ARG:     Data: Data Buffer To Calculate CRC-8/CDMA2000 For
 * ARG:     DataLength: Length Of Data Buffer
 ****************************************************************************************************/
uint8_t crc_crc8Cdma2000Calculate(const uint8_t * const Data, const uint16_t DataLength)
{
    uint8_t crc8Cdma2000 = CRC_CRC8_CDMA2000_INITIAL_CRC8_CDMA2000;
    uint32_t i;

    /*** Error Check ***/
    if((Data == NULL) || (DataLength == 0))
        return CRC_CRC8_CDMA2000_INITIAL_CRC8_CDMA2000;

    /*** Calculate Full CRC-8/CDMA2000 ***/
    for(i = 0; i < DataLength; i++)
        crc8Cdma2000 = crc_crc8Cdma2000CalculatePartial(Data[i], crc8Cdma2000);

    return crc8Cdma2000;
}

/****************************************************************************************************
 * FUNCT:   crc_crc8Cdma2000CalculatePartial
 * BRIEF:   Calculate Partial CRC-8/CDMA2000
 * RETURN:  uint8_t: Current/Final CRC-8/CDMA2000
 * ARG:     Data: Data To Add To CRC-8/CDMA2000 Calculation
 * ARG:     crc8Cdma2000: Current CRC-8/CDMA2000
 * NOTE:    Set CRC-8/CDMA2000 Value To CRC_CRC8_CDMA2000_INITIAL_CRC8_CDMA2000 If First Data Byte
 *          (Data[0]); Returned CRC-8/CDMA2000 Value Should Be Used On Subsequent Data Bytes
 *          (Data[1] ... Data[n])
 ****************************************************************************************************/
uint8_t crc_crc8Cdma2000CalculatePartial(const uint8_t Data, uint8_t crc8Cdma2000)
{
#if defined(CRC_CRC8_CDMA2000_LOOKUP_TABLE_METHOD) && defined(CRC_CRC8_CDMA2000_LOOP_METHOD)
  #error CRC_CRC8_CDMA2000_LOOKUP_TABLE_METHOD And CRC_CRC8_CDMA2000_LOOP_METHOD Cannot Both Be Defined
#elif defined(CRC_CRC8_CDMA2000_LOOKUP_TABLE_METHOD) 
    /*** Calculate Partial CRC-8/CDMA2000 ***/
    crc8Cdma2000 ^= CRC_CRC8_CDMA2000_INITIAL_CRC8_CDMA2000;
    crc8Cdma2000 = crc_crc8Cdma2000LookupTable[Data ^ crc8Cdma2000];
    return crc8Cdma2000;
#elif defined(CRC_CRC8_CDMA2000_LOOP_METHOD)
    uint8_t bit;
    
    /*** Calculate Partial CRC-8/CDMA2000 ***/
    crc8Cdma2000 ^= Data;
    for(bit = 0; bit < 8; bit++)
    {
        if((crc8Cdma2000 & 0x80) == 0x80)
            crc8Cdma2000 = (uint8_t)((crc8Cdma2000 << 1) ^ CRC_CRC8_CDMA2000_POLYNOMIAL);
        else
            crc8Cdma2000 <<= 1;
    }
    
    return crc8Cdma2000;
#endif
}
#endif

#if defined(CRC_CRC8_DARC_LOOKUP_TABLE_METHOD) || defined(CRC_CRC8_DARC_LOOP_METHOD)
/****************************************************************************************************
 * FUNCT:   crc_crc8DarcCalculate
 * BRIEF:   Calculate Full CRC-8/DARC
 * RETURN:  uint8_t: CRC-8/DARC
 * ARG:     Data: Data Buffer To Calculate CRC-8/DARC For
 * ARG:     DataLength: Length Of Data Buffer
 ****************************************************************************************************/
uint8_t crc_crc8DarcCalculate(const uint8_t * const Data, const uint16_t DataLength)
{
    uint8_t crc8Darc = CRC_CRC8_DARC_INITIAL_CRC8_DARC;
    uint32_t i;

    /*** Error Check ***/
    if((Data == NULL) || (DataLength == 0))
        return CRC_CRC8_DARC_INITIAL_CRC8_DARC;

    /*** Calculate CRC-8/DARC ***/
    for(i = 0; i < (DataLength - 1); i++)
        crc8Darc = crc_crc8DarcCalculatePartial(Data[i], crc8Darc, false);
    crc8Darc = crc_crc8DarcCalculatePartial(Data[i], crc8Darc, true);

    return crc8Darc;
}

/****************************************************************************************************
 * FUNCT:   crc_crc8DarcCalculatePartial
 * BRIEF:   Calculate Partial CRC-8/DARC
 * RETURN:  uint8_t: Current/Final CRC-8/DARC
 * ARG:     Data: Data To Add To CRC-8/DARC Calculation
 * ARG:     crc8Darc: Current CRC-8/DARC
 * ARG:     Final: Final Data (Unused If CRC_CRC8_DARC_LOOKUP_TABLE_METHOD)
 * NOTE:    Set CRC-8/DARC Value To CRC_CRC8_DARC_INITIAL_CRC8_DARC If First Data Byte (Data[0]);
 *          Returned CRC-8/DARC Value Should Be Used On Subsequent Data Bytes (Data[1] ... Data[n])
 ****************************************************************************************************/
uint8_t crc_crc8DarcCalculatePartial(const uint8_t Data, uint8_t crc8Darc, const bool Final)
{
#if defined(CRC_CRC8_DARC_LOOKUP_TABLE_METHOD) && defined(CRC_CRC8_DARC_LOOP_METHOD)
  #error CRC_CRC8_DARC_LOOKUP_TABLE_METHOD And CRC_CRC8_DARC_LOOP_METHOD Cannot Both Be Defined
#elif defined(CRC_CRC8_DARC_LOOKUP_TABLE_METHOD) 
    /*** Calculate Partial CRC-8/DARC ***/
    (void)Final; // Silence Compiler Warning
    crc8Darc = crc_crc8DarcLookupTable[Data ^ crc8Darc];
    return crc8Darc;
#elif defined(CRC_CRC8_DARC_LOOP_METHOD)
    uint8_t bit, data;
    
    /*** Reflect Input (Data) ***/
    data = crc_reflectU8(Data);
    
    /*** Calculate Partial CRC-8/DARC ***/
    crc8Darc ^= data;
    for(bit = 0; bit < 8; bit++)
    {
        if((crc8Darc & 0x80) == 0x80)
            crc8Darc = (uint8_t)((crc8Darc << 1) ^ CRC_CRC8_DARC_POLYNOMIAL);
        else
            crc8Darc <<= 1;
    }
    
    /*** Reflect Output (CRC-8/DARC) On Final Data ***/
    if(Final)
        crc8Darc = crc_reflectU8(crc8Darc);
    
    return crc8Darc;
#endif
}
#endif

#if defined(CRC_CRC8_DVB_S2_LOOKUP_TABLE_METHOD) || defined(CRC_CRC8_DVB_S2_LOOP_METHOD)
/****************************************************************************************************
 * FUNCT:   crc_crc8DvbS2Calculate
 * BRIEF:   Calculate Full CRC-8/DVB-S2
 * RETURN:  uint8_t: CRC-8/DVB-S2
 * ARG:     Data: Data Buffer To Calculate CRC-8/DVB-S2 For
 * ARG:     DataLength: Length Of Data Buffer
 ****************************************************************************************************/
uint8_t crc_crc8DvbS2Calculate(const uint8_t * const Data, const uint16_t DataLength)
{
    uint8_t crc8DvbS2 = CRC_CRC8_DVB_S2_INITIAL_CRC8_DVB_S2;
    uint32_t i;

    /*** Error Check ***/
    if((Data == NULL) || (DataLength == 0))
        return CRC_CRC8_DVB_S2_INITIAL_CRC8_DVB_S2;

    /*** Calculate Full CRC-8/DVB-S2 ***/
    for(i = 0; i < DataLength; i++)
        crc8DvbS2 = crc_crc8DvbS2CalculatePartial(Data[i], crc8DvbS2);

    return crc8DvbS2;
}

/****************************************************************************************************
 * FUNCT:   crc_crc8DvbS2CalculatePartial
 * BRIEF:   Calculate Partial CRC-8/DVB-S2
 * RETURN:  uint8_t: Current/Final CRC-8/DVB-S2
 * ARG:     Data: Data To Add To CRC-8/DVB-S2 Calculation
 * ARG:     crc8DvbS2: Current CRC-8/DVB-S2
 * NOTE:    Set CRC-8/DVB-S2 Value To CRC_CRC8_DVB_S2_INITIAL_CRC8_DVB_S2 If First Data Byte
 *          (Data[0]); Returned CRC-8/DVB-S2 Value Should Be Used On Subsequent Data Bytes
 *          (Data[1] ... Data[n])
 ****************************************************************************************************/
uint8_t crc_crc8DvbS2CalculatePartial(const uint8_t Data, uint8_t crc8DvbS2)
{
#if defined(CRC_CRC8_DVB_S2_LOOKUP_TABLE_METHOD) && defined(CRC_CRC8_DVB_S2_LOOP_METHOD)
  #error CRC_CRC8_DVB_S2_LOOKUP_TABLE_METHOD And CRC_CRC8_DVB_S2_LOOP_METHOD Cannot Both Be Defined
#elif defined(CRC_CRC8_DVB_S2_LOOKUP_TABLE_METHOD) 
    /*** Calculate Partial CRC-8/DVB-S2 ***/
    crc8DvbS2 = crc_crc8DvbS2LookupTable[Data ^ crc8DvbS2];
    return crc8DvbS2;
#elif defined(CRC_CRC8_DVB_S2_LOOP_METHOD)
    uint8_t bit;
    
    /*** Calculate Partial CRC-8/DVB-S2 ***/
    crc8DvbS2 ^= Data;
    for(bit = 0; bit < 8; bit++)
    {
        if((crc8DvbS2 & 0x80) == 0x80)
            crc8DvbS2 = (uint8_t)((crc8DvbS2 << 1) ^ CRC_CRC8_DVB_S2_POLYNOMIAL);
        else
            crc8DvbS2 <<= 1;
    }
    
    return crc8DvbS2;
#endif
}
#endif

#if defined(CRC_CRC8_EBU_LOOKUP_TABLE_METHOD) || defined(CRC_CRC8_EBU_LOOP_METHOD)
/****************************************************************************************************
 * FUNCT:   crc_crc8EbuCalculate
 * BRIEF:   Calculate Full CRC-8/EBU
 * RETURN:  uint8_t: CRC-8/EBU
 * ARG:     Data: Data Buffer To Calculate CRC-8/EBU For
 * ARG:     DataLength: Length Of Data Buffer
 ****************************************************************************************************/
uint8_t crc_crc8EbuCalculate(const uint8_t * const Data, const uint16_t DataLength)
{
    uint8_t crc8Ebu = CRC_CRC8_EBU_INITIAL_CRC8_EBU;
    uint32_t i;

    /*** Error Check ***/
    if((Data == NULL) || (DataLength == 0))
        return CRC_CRC8_EBU_INITIAL_CRC8_EBU;

    /*** Calculate CRC-8/EBU ***/
    for(i = 0; i < (DataLength - 1); i++)
        crc8Ebu = crc_crc8EbuCalculatePartial(Data[i], crc8Ebu, false);
    crc8Ebu = crc_crc8EbuCalculatePartial(Data[i], crc8Ebu, true);

    return crc8Ebu;
}

/****************************************************************************************************
 * FUNCT:   crc_crc8EbuCalculatePartial
 * BRIEF:   Calculate Partial CRC-8/EBU
 * RETURN:  uint8_t: Current/Final CRC-8/EBU
 * ARG:     Data: Data To Add To CRC-8/EBU Calculation
 * ARG:     crc8Ebu: Current CRC-8/EBU
 * ARG:     Final: Final Data (Unused If CRC_CRC8_EBU_LOOKUP_TABLE_METHOD)
 * NOTE:    Set CRC-8/EBU Value To CRC_CRC8_EBU_INITIAL_CRC8_EBU If First Data Byte (Data[0]);
 *          Returned CRC-8/EBU Value Should Be Used On Subsequent Data Bytes (Data[1] ... Data[n])
 ****************************************************************************************************/
uint8_t crc_crc8EbuCalculatePartial(const uint8_t Data, uint8_t crc8Ebu, const bool Final)
{
#if defined(CRC_CRC8_EBU_LOOKUP_TABLE_METHOD) && defined(CRC_CRC8_EBU_LOOP_METHOD)
  #error CRC_CRC8_EBU_LOOKUP_TABLE_METHOD And CRC_CRC8_EBU_LOOP_METHOD Cannot Both Be Defined
#elif defined(CRC_CRC8_EBU_LOOKUP_TABLE_METHOD) 
    /*** Calculate Partial CRC-8/EBU ***/
    (void)Final; // Silence Compiler Warning
    crc8Ebu ^= CRC_CRC8_EBU_INITIAL_CRC8_EBU;
    crc8Ebu = crc_crc8EbuLookupTable[Data ^ crc8Ebu];
    return crc8Ebu;
#elif defined(CRC_CRC8_EBU_LOOP_METHOD)
    uint8_t bit, data;
    
    /*** Reflect Input (Data) ***/
    data = crc_reflectU8(Data);
    
    /*** Calculate Partial CRC-8/EBU ***/
    crc8Ebu ^= data;
    for(bit = 0; bit < 8; bit++)
    {
        if((crc8Ebu & 0x80) == 0x80)
            crc8Ebu = (uint8_t)((crc8Ebu << 1) ^ CRC_CRC8_EBU_POLYNOMIAL);
        else
            crc8Ebu <<= 1;
    }
    
    /*** Reflect Output (CRC-8/EBU) On Final Data ***/
    if(Final)
        crc8Ebu = crc_reflectU8(crc8Ebu);
    
    return crc8Ebu;
#endif
}
#endif

#if defined(CRC_CRC8_I_CODE_LOOKUP_TABLE_METHOD) || defined(CRC_CRC8_I_CODE_LOOP_METHOD)
/****************************************************************************************************
 * FUNCT:   crc_crc8ICodeCalculate
 * BRIEF:   Calculate Full CRC-8/I-CODE
 * RETURN:  uint8_t: CRC-8/I-CODE
 * ARG:     Data: Data Buffer To Calculate CRC-8/I-CODE For
 * ARG:     DataLength: Length Of Data Buffer
 ****************************************************************************************************/
uint8_t crc_crc8ICodeCalculate(const uint8_t * const Data, const uint16_t DataLength)
{
    uint8_t crc8ICode = CRC_CRC8_I_CODE_INITIAL_CRC8_I_CODE;
    uint32_t i;

    /*** Error Check ***/
    if((Data == NULL) || (DataLength == 0))
        return CRC_CRC8_I_CODE_INITIAL_CRC8_I_CODE;

    /*** Calculate Full CRC-8/I-CODE ***/
    for(i = 0; i < DataLength; i++)
        crc8ICode = crc_crc8ICodeCalculatePartial(Data[i], crc8ICode);

    return crc8ICode;
}

/****************************************************************************************************
 * FUNCT:   crc_crc8ICodeCalculatePartial
 * BRIEF:   Calculate Partial CRC-8/I-CODE
 * RETURN:  uint8_t: Current/Final CRC-8/I-CODE
 * ARG:     Data: Data To Add To CRC-8/I-CODE Calculation
 * ARG:     crc8ICode: Current CRC-8/I-CODE
 * NOTE:    Set CRC-8/I-CODE Value To CRC_CRC8_I_CODE_INITIAL_CRC8_I_CODE If First Data Byte
 *          (Data[0]); Returned CRC-8/I-CODE Value Should Be Used On Subsequent Data Bytes
 *          (Data[1] ... Data[n])
 ****************************************************************************************************/
uint8_t crc_crc8ICodeCalculatePartial(const uint8_t Data, uint8_t crc8ICode)
{
#if defined(CRC_CRC8_I_CODE_LOOKUP_TABLE_METHOD) && defined(CRC_CRC8_I_CODE_LOOP_METHOD)
  #error CRC_CRC8_I_CODE_LOOKUP_TABLE_METHOD And CRC_CRC8_I_CODE_LOOP_METHOD Cannot Both Be Defined
#elif defined(CRC_CRC8_I_CODE_LOOKUP_TABLE_METHOD) 
    /*** Calculate Partial CRC-8/I-CODE ***/
    crc8ICode ^= CRC_CRC8_I_CODE_INITIAL_CRC8_I_CODE;
    crc8ICode = crc_crc8ICodeLookupTable[Data ^ crc8ICode];
    return crc8ICode;
#elif defined(CRC_CRC8_I_CODE_LOOP_METHOD)
    uint8_t bit;
    
    /*** Calculate Partial CRC-8/I-CODE ***/
    crc8ICode ^= Data;
    for(bit = 0; bit < 8; bit++)
    {
        if((crc8ICode & 0x80) == 0x80)
            crc8ICode = (uint8_t)((crc8ICode << 1) ^ CRC_CRC8_I_CODE_POLYNOMIAL);
        else
            crc8ICode <<= 1;
    }
    
    return crc8ICode;
#endif
}
#endif

#if defined(CRC_CRC8_ITU_LOOKUP_TABLE_METHOD) || defined(CRC_CRC8_ITU_LOOP_METHOD)
/****************************************************************************************************
 * FUNCT:   crc_crc8ItuCalculate
 * BRIEF:   Calculate Full CRC-8/ITU
 * RETURN:  uint8_t: CRC-8/ITU
 * ARG:     Data: Data Buffer To Calculate CRC-8/ITU For
 * ARG:     DataLength: Length Of Data Buffer
 ****************************************************************************************************/
uint8_t crc_crc8ItuCalculate(const uint8_t * const Data, const uint16_t DataLength)
{
    uint8_t crc8Itu = CRC_CRC8_ITU_INITIAL_CRC8_ITU;
    uint32_t i;

    /*** Error Check ***/
    if((Data == NULL) || (DataLength == 0))
        return CRC_CRC8_ITU_INITIAL_CRC8_ITU;

    /*** Calculate Full CRC-8/ITU ***/
    for(i = 0; i < (DataLength - 1); i++)
        crc8Itu = crc_crc8ItuCalculatePartial(Data[i], crc8Itu, false);
    crc8Itu = crc_crc8ItuCalculatePartial(Data[i], crc8Itu, true);

    return crc8Itu;
}

/****************************************************************************************************
 * FUNCT:   crc_crc8ItuCalculatePartial
 * BRIEF:   Calculate Partial CRC-8/ITU
 * RETURN:  uint8_t: Current/Final CRC-8/ITU
 * ARG:     Data: Data To Add To CRC-8/ITU Calculation
 * ARG:     crc8Itu: Current CRC-8/ITU
 * ARG:     Final: Final Data
 * NOTE:    Set CRC-8/ITU Value To CRC_CRC8_ITU_INITIAL_CRC8_ITU If First Data Byte (Data[0]);
 *          Returned CRC-8/ITU Value Should Be Used On Subsequent Data Bytes (Data[1] ... Data[n])
 ****************************************************************************************************/
uint8_t crc_crc8ItuCalculatePartial(const uint8_t Data, uint8_t crc8Itu, const bool Final)
{
#if defined(CRC_CRC8_ITU_LOOKUP_TABLE_METHOD) && defined(CRC_CRC8_ITU_LOOP_METHOD)
  #error CRC_CRC8_ITU_LOOKUP_TABLE_METHOD And CRC_CRC8_ITU_LOOP_METHOD Cannot Both Be Defined
#elif defined(CRC_CRC8_ITU_LOOKUP_TABLE_METHOD) 
    /*** Calculate Partial CRC-8/ITU ***/
    crc8Itu = crc_crc8ItuLookupTable[Data ^ crc8Itu];
    
    /*** XOR Output (CRC-8/ITU) On Final Data ***/
    if(Final)
        crc8Itu = crc8Itu ^ CRC_CRC8_ITU_XOR_OUT;
    
    return crc8Itu;
#elif defined(CRC_CRC8_ITU_LOOP_METHOD)
    uint8_t bit;
    
    /*** Calculate Partial CRC-8/ITU ***/
    crc8Itu ^= Data;
    for(bit = 0; bit < 8; bit++)
    {
        if((crc8Itu & 0x80) == 0x80)
            crc8Itu = (uint8_t)((crc8Itu << 1) ^ CRC_CRC8_ITU_POLYNOMIAL);
        else
            crc8Itu <<= 1;
    }
    
    /*** XOR Output (CRC-8/ITU) On Final Data ***/
    if(Final)
        crc8Itu = crc8Itu ^ CRC_CRC8_ITU_XOR_OUT;
    
    return crc8Itu;
#endif
}
#endif

#if defined(CRC_CRC8_MAXIM_LOOKUP_TABLE_METHOD) || defined(CRC_CRC8_MAXIM_LOOP_METHOD)
/****************************************************************************************************
 * FUNCT:   crc_crc8MaximCalculate
 * BRIEF:   Calculate Full CRC-8/MAXIM
 * RETURN:  uint8_t: CRC-8/MAXIM
 * ARG:     Data: Data Buffer To Calculate CRC-8/MAXIM For
 * ARG:     DataLength: Length Of Data Buffer
 ****************************************************************************************************/
uint8_t crc_crc8MaximCalculate(const uint8_t * const Data, const uint16_t DataLength)
{
    uint8_t crc8Maxim = CRC_CRC8_MAXIM_INITIAL_CRC8_MAXIM;
    uint32_t i;

    /*** Error Check ***/
    if((Data == NULL) || (DataLength == 0))
        return CRC_CRC8_MAXIM_INITIAL_CRC8_MAXIM;

    /*** Calculate CRC-8/MAXIM ***/
    for(i = 0; i < (DataLength - 1); i++)
        crc8Maxim = crc_crc8MaximCalculatePartial(Data[i], crc8Maxim, false);
    crc8Maxim = crc_crc8MaximCalculatePartial(Data[i], crc8Maxim, true);

    return crc8Maxim;
}

/****************************************************************************************************
 * FUNCT:   crc_crc8MaximCalculatePartial
 * BRIEF:   Calculate Partial CRC-8/MAXIM
 * RETURN:  uint8_t: Current/Final CRC-8/MAXIM
 * ARG:     Data: Data To Add To CRC-8/MAXIM Calculation
 * ARG:     crc8Maxim: Current CRC-8/MAXIM
 * ARG:     Final: Final Data (Unused If CRC_CRC8_MAXIM_LOOKUP_TABLE_METHOD)
 * NOTE:    Set CRC-8/MAXIM Value To CRC_CRC8_MAXIM_INITIAL_CRC8_MAXIM If First Data Byte (Data[0]);
 *          Returned CRC-8/MAXIM Value Should Be Used On Subsequent Data Bytes (Data[1] ... Data[n])
 ****************************************************************************************************/
uint8_t crc_crc8MaximCalculatePartial(const uint8_t Data, uint8_t crc8Maxim, const bool Final)
{
#if defined(CRC_CRC8_MAXIM_LOOKUP_TABLE_METHOD) && defined(CRC_CRC8_MAXIM_LOOP_METHOD)
  #error CRC_CRC8_MAXIM_LOOKUP_TABLE_METHOD And CRC_CRC8_MAXIM_LOOP_METHOD Cannot Both Be Defined
#elif defined(CRC_CRC8_MAXIM_LOOKUP_TABLE_METHOD) 
    /*** Calculate Partial CRC-8/MAXIM ***/
    (void)Final; // Silence Compiler Warning
    crc8Maxim = crc_crc8MaximLookupTable[Data ^ crc8Maxim];
    return crc8Maxim;
#elif defined(CRC_CRC8_MAXIM_LOOP_METHOD)
    uint8_t bit, data;
    
    /*** Reflect Input (Data) ***/
    data = crc_reflectU8(Data);
    
    /*** Calculate Partial CRC-8/MAXIM ***/
    crc8Maxim ^= data;
    for(bit = 0; bit < 8; bit++)
    {
        if((crc8Maxim & 0x80) == 0x80)
            crc8Maxim = (uint8_t)((crc8Maxim << 1) ^ CRC_CRC8_MAXIM_POLYNOMIAL);
        else
            crc8Maxim <<= 1;
    }
    
    /*** Reflect Output (CRC-8/MAXIM) On Final Data ***/
    if(Final)
        crc8Maxim = crc_reflectU8(crc8Maxim);
    
    return crc8Maxim;
#endif
}
#endif

#if defined(CRC_CRC8_ROHC_LOOKUP_TABLE_METHOD) || defined(CRC_CRC8_ROHC_LOOP_METHOD)
/****************************************************************************************************
 * FUNCT:   crc_crc8RohcCalculate
 * BRIEF:   Calculate Full CRC-8/ROHC
 * RETURN:  uint8_t: CRC-8/ROHC
 * ARG:     Data: Data Buffer To Calculate CRC-8/ROHC For
 * ARG:     DataLength: Length Of Data Buffer
 ****************************************************************************************************/
uint8_t crc_crc8RohcCalculate(const uint8_t * const Data, const uint16_t DataLength)
{
    uint8_t crc8Rohc = CRC_CRC8_ROHC_INITIAL_CRC8_ROHC;
    uint32_t i;

    /*** Error Check ***/
    if((Data == NULL) || (DataLength == 0))
        return CRC_CRC8_ROHC_INITIAL_CRC8_ROHC;

    /*** Calculate CRC-8/ROHC ***/
    for(i = 0; i < (DataLength - 1); i++)
        crc8Rohc = crc_crc8RohcCalculatePartial(Data[i], crc8Rohc, false);
    crc8Rohc = crc_crc8RohcCalculatePartial(Data[i], crc8Rohc, true);

    return crc8Rohc;
}

/****************************************************************************************************
 * FUNCT:   crc_crc8RohcCalculatePartial
 * BRIEF:   Calculate Partial CRC-8/ROHC
 * RETURN:  uint8_t: Current/Final CRC-8/ROHC
 * ARG:     Data: Data To Add To CRC-8/ROHC Calculation
 * ARG:     crc8Rohc: Current CRC-8/ROHC
 * ARG:     Final: Final Data (Unused If CRC_CRC8_ROHC_LOOKUP_TABLE_METHOD)
 * NOTE:    Set CRC-8/ROHC Value To CRC_CRC8_ROHC_INITIAL_CRC8_ROHC If First Data Byte (Data[0]);
 *          Returned CRC-8/ROHC Value Should Be Used On Subsequent Data Bytes (Data[1] ... Data[n])
 ****************************************************************************************************/
uint8_t crc_crc8RohcCalculatePartial(const uint8_t Data, uint8_t crc8Rohc, const bool Final)
{
#if defined(CRC_CRC8_ROHC_LOOKUP_TABLE_METHOD) && defined(CRC_CRC8_ROHC_LOOP_METHOD)
  #error CRC_CRC8_ROHC_LOOKUP_TABLE_METHOD And CRC_CRC8_ROHC_LOOP_METHOD Cannot Both Be Defined
#elif defined(CRC_CRC8_ROHC_LOOKUP_TABLE_METHOD) 
    /*** Calculate Partial CRC-8/ROHC ***/
    (void)Final; // Silence Compiler Warning
    crc8Rohc ^= CRC_CRC8_ROHC_INITIAL_CRC8_ROHC;
    crc8Rohc = crc_crc8RohcLookupTable[Data ^ crc8Rohc];
    return crc8Rohc;
#elif defined(CRC_CRC8_ROHC_LOOP_METHOD)
    uint8_t bit, data;
    
    /*** Reflect Input (Data) ***/
    data = crc_reflectU8(Data);
    
    /*** Calculate Partial CRC-8/ROHC ***/
    crc8Rohc ^= data;
    for(bit = 0; bit < 8; bit++)
    {
        if((crc8Rohc & 0x80) == 0x80)
            crc8Rohc = (uint8_t)((crc8Rohc << 1) ^ CRC_CRC8_ROHC_POLYNOMIAL);
        else
            crc8Rohc <<= 1;
    }
    
    /*** Reflect Output (CRC-8/ROHC) On Final Data ***/
    if(Final)
        crc8Rohc = crc_reflectU8(crc8Rohc);
    
    return crc8Rohc;
#endif
}
#endif

#if defined(CRC_CRC8_WCDMA_LOOKUP_TABLE_METHOD) || defined(CRC_CRC8_WCDMA_LOOP_METHOD)
/****************************************************************************************************
 * FUNCT:   crc_crc8WcdmaCalculate
 * BRIEF:   Calculate Full CRC-8/WCDMA
 * RETURN:  uint8_t: CRC-8/WCDMA
 * ARG:     Data: Data Buffer To Calculate CRC-8/WCDMA For
 * ARG:     DataLength: Length Of Data Buffer
 ****************************************************************************************************/
uint8_t crc_crc8WcdmaCalculate(const uint8_t * const Data, const uint16_t DataLength)
{
    uint8_t crc8Wcdma = CRC_CRC8_WCDMA_INITIAL_CRC8_WCDMA;
    uint32_t i;

    /*** Error Check ***/
    if((Data == NULL) || (DataLength == 0))
        return CRC_CRC8_WCDMA_INITIAL_CRC8_WCDMA;

    /*** Calculate CRC-8/WCDMA ***/
    for(i = 0; i < (DataLength - 1); i++)
        crc8Wcdma = crc_crc8WcdmaCalculatePartial(Data[i], crc8Wcdma, false);
    crc8Wcdma = crc_crc8WcdmaCalculatePartial(Data[i], crc8Wcdma, true);

    return crc8Wcdma;
}

/****************************************************************************************************
 * FUNCT:   crc_crc8WcdmaCalculatePartial
 * BRIEF:   Calculate Partial CRC-8/WCDMA
 * RETURN:  uint8_t: Current/Final CRC-8/WCDMA
 * ARG:     Data: Data To Add To CRC-8/WCDMA Calculation
 * ARG:     crc8Wcdma: Current CRC-8/WCDMA
 * ARG:     Final: Final Data (Unused If CRC_CRC8_WCDMA_LOOKUP_TABLE_METHOD)
 * NOTE:    Set CRC-8/WCDMA Value To CRC_CRC8_WCDMA_INITIAL_CRC8_WCDMA If First Data Byte (Data[0]);
 *          Returned CRC-8/WCDMA Value Should Be Used On Subsequent Data Bytes (Data[1] ... Data[n])
 ****************************************************************************************************/
uint8_t crc_crc8WcdmaCalculatePartial(const uint8_t Data, uint8_t crc8Wcdma, const bool Final)
{
#if defined(CRC_CRC8_WCDMA_LOOKUP_TABLE_METHOD) && defined(CRC_CRC8_WCDMA_LOOP_METHOD)
  #error CRC_CRC8_WCDMA_LOOKUP_TABLE_METHOD And CRC_CRC8_WCDMA_LOOP_METHOD Cannot Both Be Defined
#elif defined(CRC_CRC8_WCDMA_LOOKUP_TABLE_METHOD) 
    /*** Calculate Partial CRC-8/WCDMA ***/
    (void)Final; // Silence Compiler Warning
    crc8Wcdma = crc_crc8WcdmaLookupTable[Data ^ crc8Wcdma];
    return crc8Wcdma;
#elif defined(CRC_CRC8_WCDMA_LOOP_METHOD)
    uint8_t bit, data;
    
    /*** Reflect Input (Data) ***/
    data = crc_reflectU8(Data);
    
    /*** Calculate Partial CRC-8/WCDMA ***/
    crc8Wcdma ^= data;
    for(bit = 0; bit < 8; bit++)
    {
        if((crc8Wcdma & 0x80) == 0x80)
            crc8Wcdma = (uint8_t)((crc8Wcdma << 1) ^ CRC_CRC8_WCDMA_POLYNOMIAL);
        else
            crc8Wcdma <<= 1;
    }
    
    /*** Reflect Output (CRC-8/WCDMA) On Final Data ***/
    if(Final)
        crc8Wcdma = crc_reflectU8(crc8Wcdma);
    
    return crc8Wcdma;
#endif
}
#endif

#if defined(CRC_CRC16_ARC_LOOKUP_TABLE_METHOD) || defined(CRC_CRC16_ARC_LOOP_METHOD)
/****************************************************************************************************
 * FUNCT:   crc_crc16ArcCalculate
 * BRIEF:   Calculate Full CRC-16/ARC
 * RETURN:  uint16_t: CRC-16/ARC
 * ARG:     Data: Data Buffer To Calculate CRC-16/ARC For
 * ARG:     DataLength: Length Of Data Buffer
 ****************************************************************************************************/
uint16_t crc_crc16ArcCalculate(const uint8_t * const Data, const uint16_t DataLength)
{
    uint16_t crc16Arc = CRC_CRC16_ARC_INITIAL_CRC16_ARC;
    uint32_t i;

    /*** Error Check ***/
    if((Data == NULL) || (DataLength == 0))
        return CRC_CRC16_ARC_INITIAL_CRC16_ARC;

    /*** Calculate CRC-16/ARC ***/
    for(i = 0; i < (DataLength - 1); i++)
        crc16Arc = crc_crc16ArcCalculatePartial(Data[i], crc16Arc, false);
    crc16Arc = crc_crc16ArcCalculatePartial(Data[i], crc16Arc, true);

    return crc16Arc;
}

/****************************************************************************************************
 * FUNCT:   crc_crc16ArcCalculatePartial
 * BRIEF:   Calculate Partial CRC-16/ARC
 * RETURN:  uint16_t: Current/Final CRC-16/ARC
 * ARG:     Data: Data To Add To CRC-16/ARC Calculation
 * ARG:     crc16Arc: Current CRC-16/ARC
 * ARG:     Final: Final Data (Unused If CRC_CRC16_ARC_LOOKUP_TABLE_METHOD)
 * NOTE:    Set CRC-16/ARC Value To CRC_CRC16_ARC_INITIAL_CRC16_ARC If First Data Byte (Data[0]);
 *          Returned CRC-16/ARC Value Should Be Used On Subsequent Data Bytes (Data[1] ... Data[n])
 ****************************************************************************************************/
uint16_t crc_crc16ArcCalculatePartial(const uint8_t Data, uint16_t crc16Arc, const bool Final)
{
#if defined(CRC_CRC16_ARC_LOOKUP_TABLE_METHOD) && defined(CRC_CRC16_ARC_LOOP_METHOD)
  #error CRC_CRC16_ARC_LOOKUP_TABLE_METHOD And CRC_CRC16_ARC_LOOP_METHOD Cannot Both Be Defined
#elif defined(CRC_CRC16_ARC_LOOKUP_TABLE_METHOD) 
    /*** Calculate Partial CRC-16/ARC ***/
    (void)Final; // Silence Compiler Warning
    crc16Arc = (uint16_t)((crc16Arc >> 8) ^ crc_crc16ArcLookupTable[(uint8_t)(Data ^ (crc16Arc & 0x00FF))]);
    return crc16Arc;
#elif defined(CRC_CRC16_ARC_LOOP_METHOD)
    uint8_t bit, data;
    
    /*** Reflect Input (Data) ***/
    data = crc_reflectU8(Data);
    
    /*** Calculate Partial CRC-16/ARC ***/
    crc16Arc ^= (data << 8);
    for(bit = 0; bit < 8; bit++)
    {
        if((crc16Arc & 0x8000) == 0x8000)
            crc16Arc = (uint16_t)((crc16Arc << 1) ^ CRC_CRC16_ARC_POLYNOMIAL);
        else
            crc16Arc <<= 1;
    }
    
    /*** Reflect Output (CRC-16/ARC) On Final Data ***/
    if(Final)
        crc16Arc = crc_reflectU16(crc16Arc);
    
    return crc16Arc;
#endif
}
#endif

#if defined(CRC_CRC16_CCITT_FALSE_LOOKUP_TABLE_METHOD) || defined(CRC_CRC16_CCITT_FALSE_LOOP_METHOD)
/****************************************************************************************************
 * FUNCT:   crc_crc16CcittFalseCalculate
 * BRIEF:   Calculate Full CRC-16/CCITT-FALSE
 * RETURN:  uint16_t: CRC-16/CCITT-FALSE
 * ARG:     Data: Data Buffer To Calculate CRC-16/CCITT-FALSE For
 * ARG:     DataLength: Length Of Data Buffer
 ****************************************************************************************************/
uint16_t crc_crc16CcittFalseCalculate(const uint8_t * const Data, const uint16_t DataLength)
{
    uint16_t crc16CcittFalse = CRC_CRC16_CCITT_FALSE_INITIAL_CRC16_CCITT_FALSE;
    uint32_t i;

    /*** Error Check ***/
    if((Data == NULL) || (DataLength == 0))
        return CRC_CRC16_CCITT_FALSE_INITIAL_CRC16_CCITT_FALSE;

    /*** Calculate Full CRC-16/CCITT-FALSE ***/
    for(i = 0; i < DataLength; i++)
        crc16CcittFalse = crc_crc16CcittFalseCalculatePartial(Data[i], crc16CcittFalse);

    return crc16CcittFalse;
}

/****************************************************************************************************
 * FUNCT:   crc_crc16CcittFalseCalculatePartial
 * BRIEF:   Calculate Partial CRC-16/CCITT-FALSE
 * RETURN:  uint16_t: Current/Final CRC-16/CCITT-FALSE
 * ARG:     Data: Data To Add To CRC-16/CCITT-FALSE Calculation
 * ARG:     crc16CcittFalse: Current CRC-16/CCITT-FALSE
 * NOTE:    Set CRC-16/CCITT-FALSE Value To CRC_CRC16_CCITT_FALSE_INITIAL_CRC16_CCITT_FALSE If First
 *          Data Byte (Data[0]); Returned CRC-16/CCITT-FALSE Value Should Be Used On Subsequent Data
 *          Bytes (Data[1] ... Data[n])
 ****************************************************************************************************/
uint16_t crc_crc16CcittFalseCalculatePartial(const uint8_t Data, uint16_t crc16CcittFalse)
{
#if defined(CRC_CRC16_CCITT_FALSE_LOOKUP_TABLE_METHOD) && defined(CRC_CRC16_CCITT_FALSE_LOOP_METHOD)
  #error CRC_CRC16_CCITT_FALSE_LOOKUP_TABLE_METHOD And CRC_CRC16_CCITT_FALSE_LOOP_METHOD Cannot Both Be Defined
#elif defined(CRC_CRC16_CCITT_FALSE_LOOKUP_TABLE_METHOD) 
    /*** Calculate Partial CRC-16/CCITT-FALSE ***/
    crc16CcittFalse ^= CRC_CRC16_CCITT_FALSE_INITIAL_CRC16_CCITT_FALSE;
    crc16CcittFalse = (uint16_t)((crc16CcittFalse << 8) ^ crc_crc16CcittFalseLookupTable[(uint8_t)(Data ^ (crc16CcittFalse >> 8))]);
    return crc16CcittFalse;
#elif defined(CRC_CRC16_CCITT_FALSE_LOOP_METHOD)
    uint8_t bit;
    
    /*** Calculate Partial CRC-16/CCITT-FALSE ***/
    crc16CcittFalse ^= (Data << 8);
    for(bit = 0; bit < 8; bit++)
    {
        if((crc16CcittFalse & 0x8000) == 0x8000)
            crc16CcittFalse = (uint16_t)((crc16CcittFalse << 1) ^ CRC_CRC16_CCITT_FALSE_POLYNOMIAL);
        else
            crc16CcittFalse <<= 1;
    }
    
    return crc16CcittFalse;
#endif
}
#endif

/****************************************************************************************************
 * Function Definitions (Private)
 ****************************************************************************************************/

#ifdef CRC_REFLECT_U8
/****************************************************************************************************
 * FUNCT:   crc_reflectU8
 * BRIEF:   Reflect U8 (uint8_t)
 * RETURN:  uint8_t: Reflected U8 (uint8_t)
 * ARG:     Data: Data To Reflect
 ****************************************************************************************************/
static uint8_t crc_reflectU8(const uint8_t Data)
{
    uint8_t bit, reflectedData = 0x00;
  
    /*** Reflect U8 (uint8_t) ***/
    for(bit = 0; bit < 8; bit++)
        reflectedData |= ((Data & (1 << bit)) >> bit) << (7 - bit);
    
    return reflectedData;
}
#endif

#ifdef CRC_REFLECT_U16
/****************************************************************************************************
 * FUNCT:   crc_reflectU16
 * BRIEF:   Reflect U16 (uint16_t)
 * RETURN:  uint16_t: Reflected U16 (uint16_t)
 * ARG:     Data: Data To Reflect
 ****************************************************************************************************/
static uint16_t crc_reflectU16(const uint16_t Data)
{
    uint8_t bit;
    uint16_t reflectedData = 0x0000;
  
    /*** Reflect U16 (uint16_t) ***/
    for(bit = 0; bit < 16; bit++)
        reflectedData |= ((Data & (1 << bit)) >> bit) << (15 - bit);
    
    return reflectedData;
}
#endif
